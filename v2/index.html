<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest√µes de Java</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div id="quiz-carousel">
        <div id="slide-counter"></div>

        <div class="question-slide slide-active">
            <div class="quiz-container">
                <h1>Quest√£o 1: Classes Abstratas</h1>
                
                <p>Observe o seguinte trecho de c√≥digo em Java:</p>
                <pre class="code-block">
<code>
public abstract class ClasseDisciplina {
    protected int quantidadeAlunos;
    public abstract void atribuir();
    //...
}
</code>
                </pre>
                <p class="question-text">Assinale a seguir a alternativa que demonstra corretamente os atributos da classe apresentada.</p>

                <div class="options">
                    <div class="option">(a) Nenhum m√©todo deve ser concreto em uma classe abstrata em Java.</div>
                    <div class="option">(b) O modificador protected, em uma classe abstrata, √© obrigat√≥rio para tipos primitivos.</div>
                    <div class="option option-correct" data-id="c">(c) A express√£o public abstract indica que temos uma classe ou m√©todo abstratos.</div>
                    <div class="option">(d) O termo abstract obriga o desenvolvedor a utilizar a heran√ßa em sua implementa√ß√£o.</div>
                    <div class="option">(e) A utiliza√ß√£o de void() acarretar√° erro de compila√ß√£o se o m√©todo for abstrato.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c)</h2>
                    <p>Esta afirma√ß√£o √© 100% verdadeira e podemos v√™-la duas vezes no c√≥digo: na declara√ß√£o da classe (<code>public abstract class</code>) e na declara√ß√£o do m√©todo (<code>public abstract void</code>).</p>
                    <h3>‚ùå Por que as outras est√£o incorretas</h3>
                    <ul>
                        <li><strong>(a) Falso.</strong> Uma classe abstrata PODE ter m√©todos concretos.</li>
                        <li><strong>(b) Falso.</strong> <code>protected</code> √© um modificador de acesso e n√£o tem rela√ß√£o obrigat√≥ria com tipos primitivos.</li>
                        <li><strong>(d) Enganosa.</strong> Embora classes abstratas precisem ser herdadas, (c) √© a defini√ß√£o mais direta da sintaxe.</li>
                        <li><strong>(e) Falso.</strong> A sintaxe <code>void()</code> √© inv√°lida. O correto √© <code>void atribuir()</code>, que √© um retorno v√°lido.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 2: Generics (Declara√ß√£o)</h1>
                
                <p>Na programa√ß√£o orientada a objetos, √© comum o uso de classes e m√©todos gen√©ricos... [texto omitido] ...assinale a alternativa que apresenta, corretamente, o uso dos ‚ÄúGenerics‚Äù em linguagem Java.</p>

                <div class="options">
                    <div class="option option-correct" data-id="a">(a) List&lt;Carro&gt; carros = new ArrayList&lt;Carro&gt;()</div>
                    <div class="option">(b) list = Arrays.asList( letters );</div>
                    <div class="option">(c) Pessoa pessoa = new Pessoa();</div>
                    <div class="option">(d) List lista = new ArrayList(); lista.add(1); lista.add(‚Äúdois‚Äù);</div>
                    <div class="option">(e) Object[] pessoas = new Object[Pessoa];</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (a)</h2>
                    <p>Esta linha √© o exemplo cl√°ssico de "Generics". A sintaxe <code>&lt;Carro&gt;</code> especifica que esta <code>List</code> foi especializada para trabalhar **apenas** com objetos do tipo <code>Carro</code>.</p>
                    <h3>O Problema (Sem Generics - Alt. D)</h3>
                    <pre class="code-block"><code>// d. List lista = new ArrayList();
// Esta lista aceita TUDO:
lista.add(1);       // Um Inteiro
lista.add("dois");  // Uma String

// ERRO EM TEMPO DE EXECU√á√ÉO:
String valor = (String) lista.get(0); // Quebra!</code></pre>
                    <h3>A Solu√ß√£o (Com Generics - Alt. A)</h3>
                    <pre class="code-block"><code>// a. List&lt;Carro&gt; carros = new ArrayList&lt;Carro&gt;();
carros.add(new Carro()); // OK!

// ERRO DE COMPILA√á√ÉO!
// carros.add(1);
// carros.add("dois");

// N√£o precisa de convers√£o (cast):
Carro meuCarro = carros.get(0); // Perfeito!</code></pre>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 3: Generics (Conceito)</h1>
                
                <p>Considere o c√≥digo a seguir... [texto omitido] ...que apresenta a utiliza√ß√£o de um tipo gen√©rico para uma lista de nomes.</p>

                <pre class="code-block">
<code>
public static void main(String[] args) {
    List&lt;String&gt; nomes = new ArrayList&lt;String&gt;();
    nomes.add("Jos√©");
    nomes.add("Jo√£o");
    nomes.add("Maria");
    System.out.println(nomes.get(0));
}
</code>
                </pre>

                <p class="question-text">Em rela√ß√£o a esse c√≥digo, √© poss√≠vel afirmar que:</p>

                <div class="options">
                    <div class="option">(a) o uso do tipo gen√©rico pode ser observado nos comandos ‚Äú.add‚Äù.</div>
                    <div class="option option-correct" data-id="b">(b) o uso do tipo gen√©rico √© observado na nota√ß√£o &lt;String&gt;.</div>
                    <div class="option">(c) o uso do tipo gen√©rico √© restrito ao uso de listas e cole√ß√µes.</div>
                    <div class="option">(d) qualquer tipo de dado poderia ser adicionado √† lista, por ser gen√©rica.</div>
                    <div class="option">(e) o tipo gen√©rico aplicado √† lista √© ‚Äúnomes‚Äù.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (b)</h2>
                    <p>A sintaxe <code>&lt;String&gt;</code>, conhecida como "operador diamante" (diamond operator) ou par√¢metro de tipo, √© a forma como o Java implementa os "Generics".</p>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com o C√≥digo</h3>
                    <p>A nota√ß√£o <code>&lt;String&gt;</code> √© a defini√ß√£o do "Generics". Ela garante a seguran√ßa de tipo (Type Safety), restringindo a lista para aceitar apenas <code>String</code>.</p>

                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) Incorreto.</strong> O <code>.add</code> √© o m√©todo; o Generics <code>&lt;String&gt;</code> √© a regra que o m√©todo obedece.</li>
                        <li><strong>(d) Incorreto.</strong> Os Generics fazem o oposto: eles <strong>restringem</strong> o tipo.</li>
                        <li><strong>(e) Incorreto.</strong> <code>nomes</code> √© o nome da vari√°vel, n√£o o tipo gen√©rico.</li>
                        <li><strong>(c) Incorreto.</strong> √â o uso mais comum, mas voc√™ pode criar suas pr√≥prias classes e m√©todos gen√©ricos.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 4: Cole√ß√µes (M√©todos)</h1>
                
                <p>A estrutura de cole√ß√µes em Java fornece ao desenvolvedor diversas interfaces e classes... [texto omitido] ...Em rela√ß√£o aos m√©todos utilizados nas cole√ß√µes, analise as afirmativas a seguir.</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>A fun√ß√£o do m√©todo reverse √© inverter a ordem dos elementos em uma List.</li>
                    <li>No m√©todo fill, os elementos em uma List s√£o sobrescritos com um determinado valor.</li>
                    <li>A opera√ß√£o fill √© √∫til para limpar uma lista e bloquear suas altera√ß√µes.</li>
                    <li>Se a lista de destino for mais longa, os elementos n√£o sobrescritos sofrer√£o altera√ß√µes.</li>
                </ol>

                <p class="question-text">Est√° correto o que se afirma em:</p>

                <div class="options">
                    <div class="option">(a) I, II e IV, apenas</div>
                    <div class="option">(b) II e III, apenas</div>
                    <div class="option option-correct" data-id="c">(c) I e II, apenas</div>
                    <div class="option">(d) I, III e IV, apenas</div>
                    <div class="option">(e) I e III, apenas</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c) I e II, apenas</h2>
                    
                    <h3>üîÄ Afirmativa I: (Verdadeira) - reverse</h3>
                    <p>O m√©todo <code>Collections.reverse()</code> modifica a lista "no local" (in-place), invertendo a posi√ß√£o de todos os seus elementos.</p>
                    <pre class="code-block"><code>
List&lt;String&gt; frutas = new ArrayList&lt;&gt;(Arrays.asList("Ma√ß√£", "Banana", "Laranja"));
// Lista Original: [Ma√ß√£, Banana, Laranja]
Collections.reverse(frutas);
// Lista Revertida: [Laranja, Banana, Ma√ß√£]
                    </code></pre>

                    <h3>üé® Afirmativa II: (Verdadeira) - fill</h3>
                    <p>O m√©todo <code>Collections.fill()</code> substitui <strong>todos</strong> os elementos existentes na lista por uma c√≥pia do objeto especificado.</p>
                    <pre class="code-block"><code>
List&lt;String&gt; lista = new ArrayList&lt;&gt;(Arrays.asList("Item 1", "Item 2", "Item 3"));
// Lista Original: [Item 1, Item 2, Item 3]
Collections.fill(lista, "Substitu√≠do");
// Lista Preenchida: [Substitu√≠do, Substitu√≠do, Substitu√≠do]
                    </code></pre>

                    <h3>‚ùå Afirmativa III: (Falsa)</h3>
                    <p><code>fill</code> n√£o "limpa" a lista (como <code>.clear()</code> faz) e n√£o "bloqueia" altera√ß√µes (como <code>Collections.unmodifiableList()</code> faria). Ele <strong>√©</strong> uma altera√ß√£o.</p>

                    <h3>‚ùå Afirmativa IV: (Falsa)</h3>
                    <p><code>fill</code> sempre sobrescreve <strong>todos</strong> os elementos da lista, independentemente do seu tamanho. N√£o existem "elementos n√£o sobrescritos".</p>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 5: Iteradores (Conceito)</h1>
                
                <p>A programa√ß√£o orientada a objetos tem um importante recurso, as classes concretas de cole√ß√µes. Com base no uso da interface ‚ÄúIterator‚Äù, analise as asser√ß√µes a seguir e a rela√ß√£o proposta entre elas.</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>Uma das vantagens de usar iteradores √© que eles n√£o dependem do tipo de cole√ß√£o.</li>
                    <li>N√£o s√£o todas as cole√ß√µes que t√™m um m√©todo de remo√ß√£o por √≠ndice, como ‚ÄúList‚Äù, e cada cole√ß√£o tem uma maneira de percorrer os elementos.</li>
                </ol>

                <p class="question-text">Analisando essas asser√ß√µes, √© correto afirmar que:</p>

                <div class="options">
                    <div class="option">(a) a primeira asser√ß√£o √© falsa e a segunda √© verdadeira.</div>
                    <div class="option option-correct" data-id="b">(b) as duas asser√ß√µes s√£o verdadeiras.</div>
                    <div class="option">(c) a primeira asser√ß√£o √© verdadeira e a segunda √© falsa.</div>
                    <div class="option">(d) as duas asser√ß√µes s√£o falsas.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (b) as duas asser√ß√µes s√£o verdadeiras.</h2>
                    <p>A Asser√ß√£o II (o problema) √© a justificativa do porqu√™ a Asser√ß√£o I (a solu√ß√£o) √© t√£o vantajosa.</p>

                    <h3>üñ•Ô∏è An√°lise com C√≥digo</h3>
                    <p>Vamos usar uma <code>List</code> (que tem √≠ndice) e um <code>Set</code> (que n√£o tem) para provar as afirma√ß√µes. <code>Set</code>, por exemplo, n√£o tem √≠ndice.</p>
                    
                    <pre class="code-block"><code>
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class TesteIterador {
    public static void main(String[] args) {
        
        List&lt;String&gt; lista = new ArrayList&lt;&gt;();
        lista.add("Ana");
        lista.add("Bruno");

        Set&lt;String&gt; conjunto = new HashSet&lt;&gt;();
        conjunto.add("Carlos");
        conjunto.add("Daniela");
        
        // --- Provando a Asser√ß√£o II (O Problema) ---
        // 1. List tem √≠ndice, Set n√£o.
        lista.remove(0); // FUNCIONA!
        // conjunto.remove(0); // ERRO DE COMPILA√á√ÉO!
        
        // 2. Formas de percorrer s√£o diferentes
        // Jeito da Lista (com √≠ndice):
        for (int i = 0; i < lista.size(); i++) { /*...*/ }
        // Jeito do Set (sem √≠ndice, for-each):
        for (String nome : conjunto) { /*...*/ }

        
        // --- Provando a Asser√ß√£o I (A Solu√ß√£o) ---
        // O C√ìDIGO DO LOOP √â ID√äNTICO PARA AMBOS!
        
        Iterator&lt;String&gt; iteradorDaLista = lista.iterator();
        System.out.println("Iterador da Lista:");
        while (iteradorDaLista.hasNext()) {
            System.out.println(iteradorDaLista.next());
        }
        
        Iterator&lt;String&gt; iteradorDoSet = conjunto.iterator();
        System.out.println("Iterador do Set:");
        while (iteradorDoSet.hasNext()) {
            System.out.println(iteradorDoSet.next());
        }
    }
}
                    </code></pre>
                    
                    <h3>Conclus√£o</h3>
                    <ul>
                        <li><strong>Asser√ß√£o II √© Verdadeira:</strong> O c√≥digo prova que <code>List</code> e <code>Set</code> s√£o acessados de formas diferentes (com e sem √≠ndice).</li>
                        <li><strong>Asser√ß√£o I √© Verdadeira:</strong> O c√≥digo prova que o <code>Iterator</code> fornece uma forma √∫nica (<code>.hasNext()</code>, <code>.next()</code>) para percorrer ambos, escondendo essa diferen√ßa.</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 6: Iteradores (Uso)</h1>
                
                <p>Considere o c√≥digo em linguagem Java (qualquer vers√£o) a seguir, que apresenta o uso de um tipo gen√©rico para criar uma lista de nomes, utilizando a interface ‚ÄúIterator‚Äù para recuperar os nomes da lista.</p>

                <pre class="code-block">
<code>
public static void main(String[] args) {
    List&lt;String&gt; nomes = new ArrayList&lt;String&gt;();
    nomes.add("Jo√£o");
    nomes.add("Maria");
    nomes.add("Jos√©");  
    Iterator iterator = nomes.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
</code>
                </pre>

                <p class="question-text">Em rela√ß√£o ao c√≥digo apresentado, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) Existe um erro no c√≥digo apresentado, pois faltou a utiliza√ß√£o do m√©todo ‚Äúremove()‚Äù, para remover os itens do iterador a cada intera√ß√£o.</div>
                    <div class="option">(b) O m√©todo ‚ÄúhasNext()‚Äù, da interface ‚ÄúIterator‚Äù, √© utilizado para verificar se existem itens na lista e, em seguida, remov√™-los.</div>
                    <div class="option option-correct" data-id="c">(c) O m√©todo ‚Äúnext()‚Äù retorna o pr√≥ximo elemento do iterator, j√° no formato correto de sa√≠da, devido ao uso do tipo ‚ÄúGenerics‚Äù na lista.</div>
                    <div class="option">(d) Existe um erro no c√≥digo apresentado, pois, no comando de sa√≠da, n√£o houve a convers√£o de tipo de dados para String.</div>
                    <div class="option">(e) A limita√ß√£o do uso da interface ‚ÄúIterator‚Äù √© que ela percorre e remove os itens da lista, n√£o permitindo que a lista seja usada novamente.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c)</h2>
                    <p>O uso do Generics (<code>&lt;String&gt;</code>) na lista √© a raz√£o pela qual <code>next()</code> retorna o elemento no formato que o <code>System.out.println()</code> pode usar diretamente.</p>

                    <h3>‚úÖ (c) Por que esta √© a alternativa correta?</h3>
                    <ul>
                        <li><strong><code>List&lt;String&gt; nomes...</code></strong>: Ao usar Generics <code>&lt;String&gt;</code>, voc√™ garantiu ao compilador que esta lista S√ì cont√©m objetos <code>String</code>.</li>
                        <li><strong><code>iterator.next()</code></strong>: Quando o iterador pega o pr√≥ximo item, ele sabe que √© uma <code>String</code>.</li>
                        <li><strong>"Formato correto de sa√≠da"</strong>: O <code>System.out.println()</code> sabe como imprimir Strings. Como <code>next()</code> retorna uma <code>String</code> (gra√ßas aos Generics), o <code>println</code> a usa diretamente, sem precisar de convers√£o (cast).</li>
                    </ul>

                    <h3>‚ùå Por que as outras est√£o incorretas?</h3>
                    <ul>
                        <li><strong>(a) Falso.</strong> O m√©todo <code>remove()</code> √© opcional e usado para remover, n√£o para ler. O c√≥digo quer apenas ler/imprimir.</li>
                        <li><strong>(b) Falso.</strong> <code>hasNext()</code> √© apenas uma verifica√ß√£o (uma pergunta: "tem pr√≥ximo item?"). Ele n√£o remove nada.</li>
                        <li><strong>(d) Falso.</strong> O c√≥digo n√£o tem erro. N√£o √© necess√°ria uma convers√£o, pois o <code>System.out.println()</code> aceita o objeto retornado e o imprime.</li>
                        <li><strong>(e) Falso.</strong> O m√©todo <code>next()</code> **n√£o remove** o item, apenas avan√ßa o cursor e retorna o item. A lista <code>nomes</code> continua intacta.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 7: Cole√ß√µes (Shuffle)</h1>
                
                <p>A classe Collections fornece v√°rios algoritmos de alto desempenho... [texto omitido] ... observe o seguinte trecho de c√≥digo em Java:</p>

                <pre class="code-block">
<code>
list = Arrays.asList(deck); 
Collections.shuffle(list);
</code>
                </pre>

                <p class="question-text">Diante das informa√ß√µes apresentadas, assinale a alternativa correta a seguir.</p>

                <div class="options">
                    <div class="option option-correct" data-id="a">(a) O m√©todo shuffle ordena aleatoriamente os itens da lista passada como par√¢metro</div>
                    <div class="option">(b) O m√©todo shuffle serve para exibir os itens da lista passada como par√¢metro</div>
                    <div class="option">(c) O m√©todo asList ordena a lista de forma decrescente e exibe o resultado ao usu√°rio</div>
                    <div class="option">(d) O m√©todo shuffle serve para ordenar, de forma crescente, os itens da lista passada como par√¢metro</div>
                    <div class="option">(e) O m√©todo asList faz parte da classe Collections, com uso exclusivo do ArrayList</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (a)</h2>
                    <p>O m√©todo <code>Collections.shuffle()</code> pega uma lista e "embaralha" seus elementos, mudando suas posi√ß√µes de forma aleat√≥ria, assim como embaralhar um baralho de cartas.</p>
                    
                    <h3>üé≤ Explicando com o C√≥digo</h3>
                    <p>Vamos criar um exemplo funcional para ver o que o c√≥digo faz:</p>
                    
                    <pre class="code-block"><code>
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class TesteShuffle {
    public static void main(String[] args) {
        
        // 1. Nosso "baralho" inicial, em ordem
        String[] deck = {"√Ås", "2", "3", "4", "Rei"};

        // 2. Converte o array 'deck' em uma 'List'
        List&lt;String&gt; list = Arrays.asList(deck);
        
        System.out.println("Original: " + list);

        // 3. Embaralha a lista aleatoriamente
        Collections.shuffle(list);

        System.out.println("Embaralhado: " + list);
    }
}
// Sa√≠da de Exemplo:
// Original: [√Ås, 2, 3, 4, Rei]
// Embaralhado: [3, Rei, √Ås, 2, 4] (ser√° diferente a cada vez)
                    </code></pre>
                    
                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(b) Falso.</strong> <code>shuffle</code> modifica a lista, n√£o a exibe.</li>
                        <li><strong>(c) Falso.</strong> <code>asList</code> apenas converte, n√£o ordena.</li>
                        <li><strong>(d) Falso.</strong> O oposto. Para ordenar, usa-se <code>Collections.sort()</code>.</li>
                        <li><strong>(e) Falso.</strong> <code>asList</code> √© da classe <code>Arrays</code>, n√£o <code>Collections</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 8: Conjuntos (Set) - Caracter√≠sticas</h1>
                
                <p>Em aplica√ß√µes desenvolvidas em linguagem Java, √© muito comum o uso dos ‚ÄúConjuntos‚Äù... [texto omitido] ...Considere as caracter√≠sticas fundamentais dos conjuntos em linguagem Java, analise as afirmativas a seguir e assinale V para a(s) verdadeira(s) e F para a(s) falsa(s).</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>( ) Os elementos inseridos nos conjuntos, quando recuperados, s√£o apresentados na mesma ordem em que foram inseridos.</li>
                    <li>( ) Em rela√ß√£o ao uso dos conjuntos em linguagem Java do tipo HashSet ou TreeSet, ao se percorrer esses conjuntos, a ordem em que foram inseridos os elementos n√£o √© conhecida.</li>
                    <li>( ) Na pesquisa de dados em um conjunto do tipo HashSet ou LinkedHashSet, a velocidade √© mais r√°pida que em um objeto do tipo List.</li>
                    <li>( ) Os conjuntos n√£o aceitam valores duplicados; a tentativa de inser√ß√£o de um registro j√° existente no Set n√£o ter√° sucesso.</li>
                </ol>

                <p class="question-text">Assinale a alternativa que apresenta a sequ√™ncia correta.</p>

                <div class="options">
                    <div class="option">(a) V, F, V, F</div>
                    <div class="option">(b) F, F, F, V.</div>
                    <div class="option option-correct" data-id="c">(c) F, V, V, V.</div>
                    <div class="option">(d) V, V, V, V.</div>
                    <div class="option">(e) V, V, F, F.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c) F, V, V, V.</h2>
                    
                    <h3>‚ùå I. (Falso) Ordem de inser√ß√£o n√£o √© garantida</h3>
                    <p>A interface <code>Set</code> n√£o garante a ordem de inser√ß√£o. A implementa√ß√£o mais comum, <code>HashSet</code>, n√£o oferece nenhuma garantia sobre a ordem (pode parecer aleat√≥ria).</p>
                    <pre class="code-block"><code>
import java.util.HashSet;
import java.util.Set;

Set&lt;String&gt; meuSet = new HashSet&lt;&gt;();
meuSet.add("C");
meuSet.add("B");
meuSet.add("A");
// Ordem de Inser√ß√£o: C, B, A
// Sa√≠da Prov√°vel (HashSet): [A, B, C] (N√£o garantido)
System.out.println("HashSet: " + meuSet);
                    </code></pre>
                    <p><em>(Nota: Para manter a ordem de inser√ß√£o, voc√™ usaria um <code>LinkedHashSet</code>).</em></p>

                    <h3>‚úÖ II. (Verdadeiro) HashSet/TreeSet n√£o seguem ordem de inser√ß√£o</h3>
                    <p>Correto. <code>HashSet</code> n√£o tem ordem previs√≠vel. <code>TreeSet</code> tamb√©m n√£o segue a ordem de inser√ß√£o; ele segue a "ordem natural" (alfab√©tica, num√©rica) dos elementos.</p>
                    <pre class="code-block"><code>
Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();
Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;();
String[] frutas = {"Uva", "Ma√ß√£", "Abacaxi", "Pera"};
for (String f : frutas) { hashSet.add(f); treeSet.add(f); }
// Ordem de Inser√ß√£o: Uva, Ma√ß√£, Abacaxi, Pera
// HashSet (ordem 'hash'):   [Abacaxi, Pera, Uva, Ma√ß√£]
// TreeSet (ordem 'sorted'): [Abacaxi, Ma√ß√£, Pera, Uva]
                    </code></pre>

                    <h3>‚úÖ III. (Verdadeiro) Pesquisa √© mais r√°pida que List</h3>
                    <p>Correto. Esta √© a principal vantagem de um <code>HashSet</code>. Ele usa uma tabela hash, permitindo buscas em tempo constante (O(1)). Uma <code>List</code> precisa verificar item por item, (O(n)), o que √© muito mais lento em cole√ß√µes grandes.</p>
                    
                    <pre class="code-block"><code>
// Imagine 1.000.000 de itens em ambos...
// --- Pesquisa na LISTA (LENTA) ---
// Precisa checar 1.000.000 de itens.
boolean achouNaLista = lista.contains("Item 1000000"); 
        
// --- Pesquisa no SET (R√ÅPIDA) ---
// Calcula o hash e encontra em (idealmente) 1 opera√ß√£o.
boolean achouNoSet = conjunto.contains("Item 1000000");
                    </code></pre>

                    <h3>‚úÖ IV. (Verdadeiro) N√£o aceitam valores duplicados</h3>
                    <p>Correto. Esta √© a caracter√≠stica fundamental de um <code>Set</code>. O m√©todo <code>.add()</code> retorna <code>false</code> se o item j√° existir e n√£o o adiciona novamente.</p>
                    <pre class="code-block"><code>
Set&lt;String&gt; meuSet = new HashSet&lt;&gt;();
boolean sucesso1 = meuSet.add("Item √önico"); // Retorna true
boolean sucesso2 = meuSet.add("Item √önico"); // Retorna false
// Tamanho final do Set: 1
System.out.println("Tamanho: " + meuSet.size());
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 9: Map (containsValue)</h1>
                
                <p>Em programa√ß√£o orientada a objetos, a fun√ß√£o do Map √© conectar entre chave e valor... [texto omitido] ...A interface Java Map possui um m√©todo que permite verificar se o Map cont√©m um determinado valor. O m√©todo e uma correta chamada a ele s√£o mostrados em:</p>

                <div class="options">
                    <div class="option">(a) valueExistis(); in hasValue = map.valueExistis(‚Äúvalor 1‚Äù);</div>
                    <div class="option">(b) containsValue(); int hasValue = containsValue.StringMap(‚Äúvalor 1‚Äù);</div>
                    <div class="option">(c) containsValue(); int hasValue = map.containsValue(‚Äúvalor 1‚Äù);</div>
                    <div class="option option-correct" data-id="d">(d) containsValue(); boolean hasValue = map.containsValue(‚Äúvalor 1‚Äù);</div>
                    <div class="option">(e) valueExistis(); boolean hasValue = map.valueExistis(‚Äúvalor 1‚Äù);</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (d)</h2>
                    <p><code>containsValue(); boolean hasValue = map.containsValue(‚Äúvalor 1‚Äù);</code></p>
                    
                    <h3>üó∫Ô∏è Explica√ß√£o com C√≥digo</h3>
                    <p>O <code>Map</code> armazena pares de chave-valor (ex: "CPF" -> "Nome"). Para verificar se um <strong>valor</strong> (ex: "Nome") existe em qualquer parte do mapa, usamos o m√©todo <code>containsValue()</code>. Este m√©todo retorna um <code>boolean</code> (true ou false).</p>
                    
                    
                    <pre class="code-block"><code>
import java.util.HashMap;
import java.util.Map;

public class TesteMap {
    public static void main(String[] args) {
        
        // Criamos um Map (Chave=ID, Valor=Nome)
        Map&lt;Integer, String&gt; mapaDeNomes = new HashMap&lt;&gt;();
        
        mapaDeNomes.put(1, "Ana");
        mapaDeNomes.put(2, "Bruno");
        mapaDeNomes.put(3, "valor 1"); // O valor da pergunta
        
        // --- Esta √© a linha da alternativa (d) ---
        
        // 1. O m√©todo correto √© 'containsValue(...)'
        // 2. A chamada correta √© 'mapaDeNomes.containsValue(...)'
        // 3. O tipo de retorno √© 'boolean'
        boolean hasValue = mapaDeNomes.containsValue("valor 1");
        
        System.out.println("O mapa cont√©m 'valor 1'? " + hasValue); // Imprime: true
        
        // Testando um valor que n√£o existe
        boolean hasValue99 = mapaDeNomes.containsValue("Valor 99");
        System.out.println("O mapa cont√©m 'Valor 99'? " + hasValue99); // Imprime: false
    }
}
                    </code></pre>
                    
                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) e (e):</strong> O m√©todo <code>valueExistis</code> simplesmente n√£o existe na interface Map.</li>
                        <li><strong>(b):</strong> A sintaxe da chamada (<code>containsValue.StringMap</code>) est√° incorreta e o tipo de retorno <code>int</code> tamb√©m.</li>
                        <li><strong>(c):</strong> A sintaxe da chamada est√° correta, mas o tipo de retorno est√° errado. O m√©todo retorna <code>boolean</code> (verdadeiro/falso), n√£o <code>int</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 10: Map (Caracter√≠sticas)</h1>
                
                <p>Set e Map s√£o duas interfaces importantes do Java... [texto omitido] ...Maps diferem de Sets pelo fato de que Maps cont√™m chaves e valores, enquanto Sets cont√™m somente valores... [texto omitido] ...De acordo com o apresentado no texto, e com base nas caracter√≠sticas de Mapas, identifique se s√£o verdadeiras (V) ou falsas (F) as afirmativas a seguir.</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>( ) A interface SortedMap estende Map e mant√©m as suas chaves em ordem classificada ‚Äì na ordem natural dos elementos ou em uma ordem especificada por uma implementa√ß√£o Comparator. A classe TreeMap implementa SortedMap.</li>
                    <li>( ) As classes Hashtable e HashMap permitem usar hashes sem ter de implementar mecanismos de Tabela Hash ‚Äì um exemplo cl√°ssico da reutiliza√ß√£o, paradigma da programa√ß√£o orientada a objetos.</li>
                    <li>( ) A interface Java Map tem um m√©todo chamado putAll(), que pode copiar todos os pares chave + valor (entradas) de outra inst√¢ncia do Map para si mesmo. Na teoria dos Conjuntos, isso tamb√©m √© referido como a interse√ß√£o de duas inst√¢ncias de Map.</li>
                </ol>

                <p class="question-text">Assinale a alternativa que apresenta a sequ√™ncia correta.</p>

                <div class="options">
                    <div class="option">(a) V, V, V.</div>
                    <div class="option">(b) F, V, F.</div>
                    <div class="option">(c) V, F, V.</div>
                    <div class="option">(d) F, V, V.</div>
                    <div class="option option-correct" data-id="e">(e) V, V, F.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (e) V, V, F.</h2>
                    
                    <h3>‚úÖ I. (Verdadeiro) SortedMap e TreeMap</h3>
                    <p>Correto. <code>TreeMap</code> implementa <code>SortedMap</code> e armazena as chaves em uma √°rvore (Red-Black Tree), o que garante que as chaves estar√£o sempre em ordem (natural ou por um Comparator).</p>
                    
                    <pre class="code-block"><code>
import java.util.SortedMap;
import java.util.TreeMap;

SortedMap&lt;String, String&gt; mapaOrdenado = new TreeMap&lt;&gt;();
// Inserimos as chaves FORA de ordem alfab√©tica
mapaOrdenado.put("C-Carlos", "Valor 3");
mapaOrdenado.put("A-Ana", "Valor 1");
mapaOrdenado.put("B-Bruno", "Valor 2");

// Ao imprimir, o TreeMap garante a ordem das CHAVES
// Sa√≠da: {A-Ana=Valor 1, B-Bruno=Valor 2, C-Carlos=Valor 3}
System.out.println(mapaOrdenado); 
                    </code></pre>

                    <h3>‚úÖ II. (Verdadeiro) HashMap e Reutiliza√ß√£o</h3>
                    <p>Correto. Esta √© a ess√™ncia da abstra√ß√£o. <code>HashMap</code> √© uma estrutura de dados complexa (Tabela Hash), mas para n√≥s, ela √© uma "caixa-preta". N√≥s reutilizamos todo esse c√≥digo complexo apenas chamando m√©todos f√°ceis como <code>.put()</code> e <code>.get()</code>.</p>
                    
                    <pre class="code-block"><code>
import java.util.Map;
import java.util.HashMap;

// Usamos o HashMap sem saber como ele funciona por dentro
Map&lt;String, Integer&gt; mapaHash = new HashMap&lt;&gt;();

// REUTILIZA√á√ÉO: N√£o implementamos o hash, s√≥ usamos:
mapaHash.put("Ana", 30);
Integer idade = mapaHash.get("Ana");
                    </code></pre>

                    <h3>‚ùå III. (Falso) putAll() √© UNI√ÉO, n√£o Interse√ß√£o</h3>
                    <p>Correto, o m√©todo <code>putAll()</code> existe, mas ele executa uma <strong>UNI√ÉO</strong> (adiciona todos os elementos do mapaB no mapaA), n√£o uma <strong>interse√ß√£o</strong> (que manteria apenas os elementos em comum).</p>
                    <pre class="code-block"><code>
Map&lt;Integer, String&gt; mapaA = new HashMap&lt;&gt;();
mapaA.put(1, "Item 1-A"); // Chave 1
mapaA.put(2, "Item 2-A"); // Chave 2

Map&lt;Integer, String&gt; mapaB = new HashMap&lt;&gt;();
mapaB.put(2, "Item 2-B"); // Chave 2 (sobrescrever√°)
mapaB.put(3, "Item 3-B"); // Chave 3
        
// Isso √© uma UNI√ÉO
mapaA.putAll(mapaB);
        
// Sa√≠da: {1=Item 1-A, 2=Item 2-B, 3=Item 3-B}
System.out.println(mapaA);
                    </code></pre>
                    <p>O resultado final (chaves 1, 2 e 3) √© a uni√£o de todas as chaves, provando que a afirmativa √© falsa.</p>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 11: Set (Implementa√ß√µes)</h1>
                
                <p>Um Conjunto √© uma Cole√ß√£o que n√£o pode conter elementos duplicados... [texto omitido] ...Duas inst√¢ncias de Set s√£o iguais se contiverem os mesmos elementos. Observe as afirma√ß√µes a seguir, sobre as Cole√ß√µes em Java, e correlacione-as, adequadamente, aos termos aos quais se referem.</p>

                <div style="display: flex; justify-content: space-around; margin-bottom: 15px;">
                    <ol style="list-style-type: decimal; padding-left: 20px;">
                        <li>TreeSet</li>
                        <li>HashSet</li>
                        <li>LinkedHashSet</li>
                    </ol>
                    <ol style="list-style-type: upper-roman; padding-left: 20px; max-width: 60%;">
                        <li>Armazena os seus elementos em uma Tabela Hash. √â a implementa√ß√£o de melhor desempenho; no entanto, n√£o oferece garantias quanto √† ordem de itera√ß√£o.</li>
                        <li>Armazena os seus elementos em uma √°rvore rubro-negra, ordena os seus elementos com base em seus valores e √©, substancialmente, mais lento do que outros Conjuntos.</li>
                        <li>√â implementado como uma Tabela Hash com uma lista encadeada passando por ela e ordena os seus elementos com base na ordem em que foram inseridos no Conjunto.</li>
                    </ol>
                </div>

                <p class="question-text">Assinale a alternativa que correlaciona, adequadamente, os dois grupos de informa√ß√£o.</p>

                <div class="options">
                    <div class="option">(a) 1-I; 2-II; 3-III.</div>
                    <div class="option">(b) 1-II; 2-III; 3-I.</div>
                    <div class="option option-correct" data-id="c">(c) 1-II; 2-I; 3-III.</div>
                    <div class="option">(d) 1-III; 2-I; 3-II.</div>
                    <div class="option">(e) 1-III; 2-II; 3-I.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c) 1-II; 2-I; 3-III.</h2>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com C√≥digo</h3>
                    <p>Vamos usar um exemplo de c√≥digo √∫nico que insere os mesmos elementos (fora de ordem) em todos os tr√™s tipos de Set para demonstrar por que as ordens de armazenamento e as caracter√≠sticas s√£o diferentes.</p>

                    <pre class="code-block"><code>
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.TreeSet;
import java.util.Set;

public class TesteConjuntos {
    public static void main(String[] args) {
        // A ordem de inser√ß√£o ser√°: Uva, Ma√ß√£, Pera, Abacaxi
        System.out.println("Ordem de Inser√ß√£o: Uva, Ma√ß√£, Pera, Abacaxi\n");

        // --- 2-I: HashSet (Tabela Hash, sem ordem) ---
        // I. Armazena... em uma Tabela Hash... n√£o oferece garantias...
        
        Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();
        hashSet.add("Uva");
        hashSet.add("Ma√ß√£");
        hashSet.add("Pera");
        hashSet.add("Abacaxi");
        // A sa√≠da N√ÉO √© a ordem de inser√ß√£o e N√ÉO √© a ordem alfab√©tica.
        // √â a ordem baseada no 'hash' de cada String. √â o mais r√°pido (O(1)).
        System.out.println("2-I (HashSet): " + hashSet);

        // --- 1-II: TreeSet (√Årvore, ordem classificada) ---
        // II. Armazena... em uma √°rvore rubro-negra, ordena...
        
        Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;();
        treeSet.add("Uva");
        treeSet.add("Ma√ß√£");
        treeSet.add("Pera");
        treeSet.add("Abacaxi");
        // A sa√≠da √© classificada em ORDEM ALFAB√âTICA (ordem natural).
        // √â mais lento (O(log n)) pois precisa manter a √°rvore ordenada.
        System.out.println("1-II (TreeSet): " + treeSet);

        // --- 3-III: LinkedHashSet (Hash + Lista Encadeada, ordem de inser√ß√£o) ---
        // III. ...Tabela Hash com uma lista encadeada... ordena... na ordem...
        
        Set&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();
        linkedHashSet.add("Uva");
        linkedHashSet.add("Ma√ß√£");
        linkedHashSet.add("Pera");
        linkedHashSet.add("Abacaxi");
        // A sa√≠da √© EXATAMENTE a ordem em que inserimos os itens.
        System.out.println("3-III (LinkedHashSet): " + linkedHashSet);
    }
}
// Sa√≠da Prov√°vel do C√≥digo:
// Ordem de Inser√ß√£o: Uva, Ma√ß√£, Pera, Abacaxi
//
// 2-I (HashSet): [Abacaxi, Pera, Uva, Ma√ß√£]
// 1-II (TreeSet): [Abacaxi, Ma√ß√£, Pera, Uva]
// 3-III (LinkedHashSet): [Uva, Ma√ß√£, Pera, Abacaxi]
                    </code></pre>

                    <h3>Conclus√£o</h3>
                    <p>O c√≥digo demonstra claramente as correla√ß√µes:</p>
                    <ul>
                        <li><strong>HashSet (2-I):</strong> A ordem √© "aleat√≥ria" (baseada em hash), provando a descri√ß√£o I.</li>
                        <li><strong>TreeSet (1-II):</strong> A ordem √© alfab√©tica (classificada), provando a descri√ß√£o II.</li>
                        <li><strong>LinkedHashSet (3-III):</strong> A ordem √© id√™ntica √† de inser√ß√£o, provando a descri√ß√£o III.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 12: Set (Duplicados)</h1>
                
                <p>Considere o c√≥digo em linguagem Java (qualquer vers√£o) a seguir, que apresenta a utiliza√ß√£o de um conjunto para uma lista de nomes.</p>

                <pre class="code-block">
<code>
public static void main(String[] args) {
    Set&lt;String&gt; nomes = new HashSet&lt;&gt;();
    nomes.add("Jo√£o");
    nomes.add("Jos√©");
    nomes.add("Maria");
    nomes.add("Carlos");
    nomes.add("Maria");
    nomes.add("Jo√£o");
    System.out.println(nomes);
}
</code>
                </pre>

                <p class="question-text">Em rela√ß√£o ao c√≥digo apresentado, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) O c√≥digo apresentado cria um conjunto do tipo List de ‚Äúnomes‚Äù.</div>
                    <div class="option option-correct" data-id="b">(b) O m√©todo imprime todos os nomes do conjunto, exceto os duplicados.</div>
                    <div class="option">(c) O m√©todo imprime todos os nomes do conjunto na ordem em que foram inseridos.</div>
                    <div class="option">(d) O m√©todo imprime todos os nomes do conjunto em ordem alfab√©tica.</div>
                    <div class="option">(e) O uso de um conjunto pode ser observado nos comandos ‚Äú.add‚Äù.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (b)</h2>
                    <p>A caracter√≠stica fundamental de um <code>Set</code> (Conjunto), e especificamente do <code>HashSet</code> usado no c√≥digo, √© que ele **n√£o permite elementos duplicados**.</p>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com o C√≥digo</h3>
                    
                    <p>Vamos analisar o que acontece linha por linha no m√©todo <code>main</code>:</p>
                    
                    <pre class="code-block"><code>
public static void main(String[] args) {
    // 1. Voc√™ cria um CONJUNTO (Set) do tipo HashSet.
    Set&lt;String&gt; nomes = new HashSet&lt;&gt;();

    // 2. Adiciona os nomes
    nomes.add("Jo√£o");     // OK. Set agora √©: [Jo√£o]
    nomes.add("Jos√©");     // OK. Set agora √©: [Jo√£o, Jos√©]
    nomes.add("Maria");    // OK. Set agora √©: [Jo√£o, Jos√©, Maria]
    nomes.add("Carlos");   // OK. Set agora √©: [Jo√£o, Jos√©, Maria, Carlos]

    // 3. Tentativa de adicionar duplicados
    nomes.add("Maria");    // "Maria" J√Å EXISTE. O Set ignora esta adi√ß√£o.
    nomes.add("Jo√£o");     // "Jo√£o" J√Å EXISTE. O Set ignora esta adi√ß√£o.

    // 4. Impress√£o
    // O Set cont√©m apenas as entradas √∫nicas.
    System.out.println(nomes);
}
// Sa√≠da Prov√°vel do Programa:
// [Carlos, Jos√©, Jo√£o, Maria] 
// (A ordem n√£o √© garantida)
                    </code></pre>
                    <p>A sa√≠da prova que, embora voc√™ tenha chamado <code>.add()</code> seis vezes, o <code>Set</code> s√≥ armazenou os quatro valores √∫nicos, exatamente como a alternativa (b) descreve.</p>
                    
                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) Falso.</strong> O c√≥digo cria um <code>Set</code>, n√£o uma <code>List</code>.</li>
                        <li><strong>(c) Falso.</strong> A ordem de inser√ß√£o n√£o √© mantida por um <code>HashSet</code> (isso seria um <code>LinkedHashSet</code>).</li>
                        <li><strong>(d) Falso.</strong> A ordem alfab√©tica n√£o √© mantida por um <code>HashSet</code> (isso seria um <code>TreeSet</code>).</li>
                        <li><strong>(e) Falso.</strong> O m√©todo <code>.add</code> √© comum a muitas cole√ß√µes. O que define o conjunto √© a declara√ß√£o <code>Set&lt;String&gt; ... = new HashSet&lt;&gt;()</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 13: HashSet (Hashing)</h1>
                
                <p>A classe Java HashSet √© usada para criar uma Cole√ß√£o que usa uma Tabela Hash para armazenamento... [texto omitido] ...Sobre a classe HashSet e as caracter√≠sticas de conjunto em Java, avalie as afirmativas a seguir.</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>( ) O HashSet possui como mecanismo de armazenamento de elementos o hashing.</li>
                    <li>( ) O HashSet cont√©m apenas elementos exclusivos, podendo ser nulos.</li>
                    <li>( ) O HashSet mant√©m a ordem de inser√ß√£o, al√©m de salvar os HashCode.</li>
                </ol>

                <p class="question-text">Est√° correto o que se afirma em:</p>

                <div class="options">
                    <div class="option option-correct" data-id="a">(a) I e II, apenas.</div>
                    <div class="option">(b) I, II e III, apenas.</div>
                    <div class="option">(c) II e III, apenas.</div>
                    <div class="option">(d) I e III, apenas.</div>
                    <div class="option">(e) I, apenas.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (a) I e II, apenas.</h2>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com C√≥digo</h3>
                    
                    <p>Usaremos um <code>HashSet</code> para testar todas as tr√™s afirma√ß√µes simultaneamente.</p>
                    
                    <pre class="code-block"><code>
import java.util.HashSet;
import java.util.Set;

public class TesteHashSet {
    public static void main(String[] args) {
        
        Set&lt;String&gt; meuSet = new HashSet&lt;&gt;();

        // --- Demonstra√ß√£o de I e III (Hashing e Ordem) ---
        
        // I. O 'HashSet' usa 'hashing'. 
        // III. O 'HashSet' N√ÉO mant√©m a ordem de inser√ß√£o.
        System.out.println("Ordem de Inser√ß√£o: Zeta, Beta, Alfa");
        meuSet.add("Zeta");   // Inserido primeiro
        meuSet.add("Beta");   // Inserido em segundo
        meuSet.add("Alfa");   // Inserido por √∫ltimo

        // A sa√≠da N√ÉO ser√° a ordem de inser√ß√£o (Zeta, Beta, Alfa)
        // A sa√≠da √© determinada pelo 'hashCode' das strings.
        System.out.println("Ordem de Recupera√ß√£o: " + meuSet);
        System.out.println("=> Afirma√ß√£o I (usa hashing) √© VERDADEIRA.");
        System.out.println("=> Afirma√ß√£o III (mant√©m ordem) √© FALSA.");


        // --- Demonstra√ß√£o de II (Exclusivos e Nulos) ---
        System.out.println("\n--- Testando Exclusivos e Nulos ---");

        // II. ...cont√©m apenas elementos exclusivos...
        boolean sucessoDuplicado = meuSet.add("Alfa"); // Tentando adicionar "Alfa" novamente
        System.out.println("Add 'Alfa' duplicado: " + sucessoDuplicado); // Retorna 'false'
        
        // II. ...podendo ser nulos.
        boolean sucessoNulo = meuSet.add(null);
        System.out.println("Add 'null' (1¬™ vez): " + sucessoNulo); // Retorna 'true'
        
        // Tentando adicionar 'null' duplicado
        boolean sucessoNulo2 = meuSet.add(null);
        System.out.println("Add 'null' (2¬™ vez): " + sucessoNulo2); // Retorna 'false'

        System.out.println("Conte√∫do final: " + meuSet);
        System.out.println("=> Afirma√ß√£o II √© VERDADEIRA.");
    }
}
// Sa√≠da Prov√°vel:
// Ordem de Inser√ß√£o: Zeta, Beta, Alfa
// Ordem de Recupera√ß√£o: [Alfa, Beta, Zeta]
// => Afirma√ß√£o I (usa hashing) √© VERDADEIRA.
// => Afirma√ß√£o III (mant√©m ordem) √© FALSA.
//
// --- Testando Exclusivos e Nulos ---
// Add 'Alfa' duplicado: false
// Add 'null' (1¬™ vez): true
// Add 'null' (2¬™ vez): false
// Conte√∫do final: [null, Alfa, Beta, Zeta]
// => Afirma√ß√£o II √© VERDADEIRA.
                    </code></pre>
                    
                    <h3>Conclus√£o</h3>
                    <ul>
                        <li><strong>I. (Verdadeiro):</strong> O nome <code>HashSet</code> significa "Conjunto baseado em Hash". Ele usa o <code>hashCode()</code> dos objetos para determinar onde armazen√°-los.</li>
                        <li><strong>II. (Verdadeiro):</strong> O c√≥digo prova que o <code>Set</code> ignora a tentativa de adicionar "Alfa" uma segunda vez e tamb√©m ignora a tentativa de adicionar <code>null</code> uma segunda vez.</li>
                        <li><strong>III. (Falso):</strong> O c√≥digo prova que a ordem de recupera√ß√£o (<code>[Alfa, Beta, Zeta]</code>) n√£o tem rela√ß√£o com a ordem de inser√ß√£o (<code>Zeta, Beta, Alfa</code>). A classe que mant√©m a ordem de inser√ß√£o √© a <code>LinkedHashSet</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 14: Map (Conceito)</h1>
                
                <p>A linguagem Java disp√µe de um importante recurso, a interface ‚ÄúMap‚Äù. Nesse sentido, analise as asser√ß√µes a seguir e a rela√ß√£o proposta entre elas.</p>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>( ) Um mapa √© composto por um conjunto de associa√ß√µes entre um objeto-chave e um objeto-valor, sendo equivalente ao conceito de dicion√°rio, presente em outras linguagens de programa√ß√£o.</li>
                    <li>( ) O uso de mapas √© bastante interessante, quando queremos buscar um objeto pela sua chave.</li>
                </ol>

                <p class="question-text">Analisando essas asser√ß√µes, √© correto afirmar que:</p>

                <div class="options">
                    <div class="option">(a) a primeira asser√ß√£o √© verdadeira e a segunda √© falsa.</div>
                    <div class="option">(b) a primeira asser√ß√£o √© falsa e a segunda √© verdadeira.</div>
                    <div class="option">(c) as duas asser√ß√µes s√£o falsas.</div>
                    <div class="option option-correct" data-id="d">(d) as duas asser√ß√µes s√£o verdadeiras.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (d) as duas asser√ß√µes s√£o verdadeiras.</h2>
                    <p>As duas afirma√ß√µes n√£o s√£o apenas verdadeiras, mas a Asser√ß√£o I (a estrutura) √© o que torna a Asser√ß√£o II (a utilidade) poss√≠vel.</p>
                    
                    <h3>üó∫Ô∏è Explica√ß√£o com C√≥digo</h3>
                    
                    <p>Vamos usar um exemplo pr√°tico: um "dicion√°rio" que armazena o CPF (a Chave) e o Nome (o Valor) de uma pessoa.</p>

                    <pre class="code-block"><code>
import java.util.Map;
import java.util.HashMap;

public class TesteMap {
    public static void main(String[] args) {
        
        // --- Demonstra√ß√£o da Asser√ß√£o I ---
        // A interface Map (ex: HashMap) armazena "associa√ß√µes" (Key-Value)
        // √â um "Dicion√°rio" de pessoas.
        Map&lt;String, String&gt; dicionarioPessoas = new HashMap&lt;&gt;();
        
        // Criando as associa√ß√µes
        dicionarioPessoas.put("111.222.333-44", "Ana Silva");
        dicionarioPessoas.put("555.666.777-88", "Bruno Costa");
        dicionE;rioPessoas.put("999.888.777-66", "Carla Dias");
        
        System.out.println("O Dicion√°rio completo: " + dicionarioPessoas);

        // --- Demonstra√ß√£o da Asser√ß√£o II ---
        // O "uso interessante" √© buscar o Valor (Nome)
        // usando a Chave (CPF). Isso √© extremamente r√°pido.
        
        String cpfParaBuscar = "555.666.777-88";
        // Usamos o m√©todo .get(chave)
        String nomeEncontrado = dicionarioPessoas.get(cpfParaBuscar);
        
        System.out.println("\nBuscando pelo CPF: " + cpfParaBuscar);
        System.out.println("Nome encontrado: " + nomeEncontrado); // Sa√≠da: Bruno Costa
    }
}
                    </code></pre>
                    
                    <h3>Conclus√£o</h3>
                    <ul>
                        <li><strong>Asser√ß√£o I (Verdadeira):</strong> O c√≥digo mostra a cria√ß√£o de um "dicion√°rio" (o <code>Map</code>) que armazena um conjunto de associa√ß√µes (Chave/Valor, como "CPF" -> "Nome").</li>
                        <li><strong>Asser√ß√£o II (Verdadeira):</strong> O c√≥digo demonstra que o principal uso do <code>Map</code> √© buscar o valor ("Bruno Costa") de forma eficiente usando o m√©todo <code>.get()</code> e passando a chave ("555.666.777-88").</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 15: Recurs√£o (Fibonacci)</h1>
                
                <p>A utiliza√ß√£o de recursividade... [texto omitido] ... Observe o trecho de c√≥digo a seguir, realizado na linguagem Java, vers√£o 8.</p>

                <pre class="code-block">
<code>
public static BigInteger fibonacci(BigInteger number)
{
    if(number.equals(BigInteger.ZERO) ||
       number.equals(BigInteger.ONE)) //casos b√°sicos
        return number;
    else //passo de recurs√£o
        return fibonacci(number.subtract(BigInteger.ONE)).add(
               fibonacci(number.subtract(TWO)));
}
</code>
                </pre>

                <ol style="list-style-type: upper-roman; margin-left: 20px; padding-left: 10px;">
                    <li>( ) A codifica√ß√£o mostrada possui erro sint√°tico, pois, nessa chamada recursiva, o m√©todo Fibonacci est√° chamando outro m√©todo para c√°lculo de mesmo nome, retornando uma chamada tamb√©m com o mesmo nome de m√©todo.</li>
                    <li>( ) A condi√ß√£o ‚Äúnumber.equals(BigInteger.ZERO)‚Äù permite que todo trecho de c√≥digo n√£o necessite ser executado, uma vez que a estrutura ‚Äúif‚Ä¶else‚Äù est√° limitando a execu√ß√£o caso o ‚Äúif‚Äù inicial seja verdadeiro.</li>
                    <li>( ) √â poss√≠vel realizar opera√ß√µes matem√°ticas por meio de m√©todos com c√°lculos predefinidos, seja para compara√ß√£o, subtra√ß√£o ou adi√ß√£o num√©rica, passando como par√¢metro o valor desejado.</li>
                </ol>

                <p class="question-text">Est√° correto o que se afirma em:</p>

                <div class="options">
                    <div class="option">(a) I e II, apenas.</div>
                    <div class="option">(b) I, apenas.</div>
                    <div class="option">(c) I e III, apenas.</div>
                    <div class="option option-correct" data-id="d">(d) II e III, apenas.</div>
                    <div class="option">(e) I, II e III, apenas.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (d) II e III, apenas.</h2>
                    
                    <h3>üñ•Ô∏è An√°lise do C√≥digo</h3>
                    <p>Vamos analisar as afirmativas com base no c√≥digo, que calcula a sequ√™ncia de Fibonacci usando recurs√£o e a classe <code>BigInteger</code> para n√∫meros grandes.</p>
                    
                    <h3>‚ùå Afirmativa I (Falsa)</h3>
                    <p><strong>"A codifica√ß√£o mostrada possui erro sint√°tico..."</strong></p>
                    <p>Isto est√° falso. A afirma√ß√£o descreve a defini√ß√£o de recurs√£o como se fosse um erro. Um m√©todo recursivo √©, por defini√ß√£o, um m√©todo que chama a si mesmo. A linha <code>return fibonacci(...).add(fibonacci(...));</code> mostra o m√©todo <code>fibonacci</code> chamando a si mesmo com valores menores. Isso n√£o √© um erro sint√°tico, √© a ess√™ncia da recurs√£o.</p>

                    <h3>‚úÖ Afirmativa II (Verdadeira)</h3>
                    <p><strong>"A condi√ß√£o ‚Äúnumber.equals(BigInteger.ZERO)‚Äù... limita a execu√ß√£o caso o ‚Äúif‚Äù inicial seja verdadeiro."</strong></p>
                    <p>Isto est√° verdadeiro. Esta √© a <strong>"condi√ß√£o de parada"</strong> (ou caso b√°sico) da recurs√£o. O <code>if</code> e o <code>else</code> s√£o mutuamente exclusivos. Se o n√∫mero for 0 ou 1, o m√©todo executa <code>return number;</code> e termina imediatamente. O bloco <code>else</code>, que cont√©m as chamadas recursivas, √© completamente ignorado. √â isso que impede que a recurs√£o se torne um loop infinito.</p>
                    
                    
                    <h3>‚úÖ Afirmativa III (Verdadeira)</h3>
                    <p><strong>"√â poss√≠vel realizar opera√ß√µes matem√°ticas por meio de m√©todos com c√°lculos predefinidos..."</strong></p>
                    <p>Isto est√° verdadeiro. O c√≥digo prova essa afirma√ß√£o. Como <code>BigInteger</code> √© uma classe (um objeto) e n√£o um tipo primitivo (como <code>int</code>), n√£o podemos usar os operadores matem√°ticos tradicionais (<code>+</code>, <code>-</code>, <code>==</code>). Somos obrigados a usar os m√©todos que a classe <code>BigInteger</code> fornece:</p>
                    
                    <ul>
                        <li><strong>Compara√ß√£o:</strong> <code>number.equals(BigInteger.ZERO)</code> (em vez de <code>number == 0</code>)</li>
                        <li><strong>Subtra√ß√£o:</strong> <code>number.subtract(BigInteger.ONE)</code> (em vez de <code>number - 1</code>)</li>
                        <li><strong>Adi√ß√£o:</strong> <code>... .add(...)</code> (em vez de <code>... + ...</code>)</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 16: Conjuntos (Defini√ß√£o)</h1>
                
                <p>Na linguagem Java, √© comum o uso da classe ‚ÄúCollection‚Äù, que tem classes-filhas para listas e conjuntos... [texto omitido] ...Em rela√ß√£o ao melhor uso dos conjuntos em linguagem Java, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) Exemplos de conjuntos s√£o as classes List e Queue.</div>
                    <div class="option">(b) Os conjuntos s√£o definidos pela classe Vector, permitindo a duplicidade de elementos.</div>
                    <div class="option">(c) Os conjuntos s√£o uma cole√ß√£o ordenada de elementos.</div>
                    <div class="option">(d) Os conjuntos s√£o definidos pela classe ArrayList.</div>
                    <div class="option option-correct" data-id="e">(e) Os conjuntos s√£o uma Collection que n√£o permite elementos duplicados.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (e)</h2>
                    <p>Esta √© a caracter√≠stica fundamental que define um <strong>Set (Conjunto)</strong> em Java. Ele √© modelado exatamente como um conjunto matem√°tico: uma cole√ß√£o de itens √∫nicos.</p>
                    

[Image of Venn diagram showing unique sets]

                    
                    <h3>üñ•Ô∏è Explica√ß√£o com C√≥digo</h3>
                    <p>A melhor forma de demonstrar isso √© tentar adicionar um item duplicado a um <code>Set</code> e ver o que acontece. Usaremos a implementa√ß√£o mais comum, <code>HashSet</code>.</p>
                    
                    <pre class="code-block"><code>
import java.util.HashSet;
import java.util.Set;

public class TesteConjunto {
    public static void main(String[] args) {
        
        // Criamos um 'Set' (Conjunto) de Strings
        Set&lt;String&gt; frutas = new HashSet&lt;&gt;();

        System.out.println("--- Adicionando elementos ---");
        
        // .add() retorna 'true' se o item foi adicionado
        System.out.println("Adicionando 'Ma√ß√£':   " + frutas.add("Ma√ß√£"));
        System.out.println("Adicionando 'Banana': " + frutas.add("Banana"));
        
        System.out.println("\nSet atual: " + frutas);
        System.out.println("Tamanho atual: " + frutas.size()); // Tamanho √© 2
        
        System.out.println("\n--- Tentando adicionar um duplicado ---");
        
        // Tentando adicionar "Ma√ß√£" novamente
        // O m√©todo .add() retornar√° 'false', pois o item j√° existe.
        System.out.println("Adicionando 'Ma√ß√£' de novo: " + frutas.add("Ma√ß√£"));

        // O 'Set' e seu tamanho n√£o mudam
        System.out.println("\nSet final: " + frutas);
        System.out.println("Tamanho final: " + frutas.size()); // Tamanho continua 2
    }
}
// Sa√≠da:
// --- Adicionando elementos ---
// Adicionando 'Ma√ß√£':   true
// Adicionando 'Banana': true
// Set atual: [Banana, Ma√ß√£]
// Tamanho atual: 2
//
// --- Tentando adicionar um duplicado ---
// Adicionando 'Ma√ß√£' de novo: false
// Set final: [Banana, Ma√ß√£]
// Tamanho final: 2
                    </code></pre>
                    <p>Como o c√≥digo prova, a segunda tentativa de adicionar "Ma√ß√£" falhou (o m√©todo <code>add</code> retornou <code>false</code>) e o <code>Set</code> ignorou o elemento duplicado.</p>

                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) Falso.</strong> <code>List</code> (Lista) e <code>Queue</code> (Fila) s√£o outras interfaces da <code>Collection</code>, distintas de <code>Set</code> (Conjunto).</li>
                        <li><strong>(b) Falso.</strong> <code>Vector</code> √© uma implementa√ß√£o de <code>List</code>, n√£o de <code>Set</code>, e permite duplicidade.</li>
                        <li><strong>(c) Falso.</strong> A interface <code>Set</code> em si n√£o garante ordem. <code>HashSet</code> (o mais comum) n√£o √© ordenado. (<code>TreeSet</code> √© ordenado por valor e <code>LinkedHashSet</code> √© ordenado por inser√ß√£o).</li>
                        <li><strong>(d) Falso.</strong> <code>ArrayList</code> tamb√©m √© uma implementa√ß√£o de <code>List</code>, n√£o de <code>Set</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 17: Map (entrySet / getKey)</h1>
                
                <p>Os Mapas de Hash s√£o estruturas de dados indexados... [texto omitido] ...Considere a seguinte codifica√ß√£o em Java...</p>

                <pre class="code-block">
<code>
Set set = hm.entrySet();
Iterator iterator = set.iterator();
while(iterator.hasNext()){
    Map.Entry mentry = (Map.Entry)iterator.next();
    System.out.print("A chave √©: " + mentry.getKey() + "& o Valor √©: ");   
    System.out.println(mentry.getValue());
}
//Obt√©m valores baseado na chave
String var = hm.get(2);
System.out.println("Valor no √≠ndice 2 √©: " + var);
</code>
                </pre>

                <p class="question-text">Sobre o c√≥digo anterior, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) A express√£o ‚ÄúSystem.out.println‚Äù permite a exibi√ß√£o da sa√≠da do sistema em uma janela baseada em frames.</div>
                    <div class="option option-correct" data-id="b">(b) O m√©todo mentry.getKey() serve para obter a chave da rela√ß√£o Hash, e o ‚Äúmentry.getValue()‚Äù, o seu valor.</div>
                    <div class="option">(c) O c√≥digo utiliza-se de conjuntos, que s√£o estruturas mais eficientes e mais r√°pidas do que os Mapas.</div>
                    <div class="option">(d) A express√£o ‚Äúget(2)‚Äù ocasionar√° um erro no valor, pois, em Hash, as respostas devem ser do tipo inteiro.</div>
                    <div class="option">(e) Em ‚ÄúMap.Entry mentry‚Äù teremos um erro de compila√ß√£o, devido √† incompatibilidade com a classe Iterator.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (b)</h2>
                    
                    <h3>üñ•Ô∏è An√°lise do C√≥digo</h3>
                    
                    <p>O objetivo do primeiro bloco de c√≥digo √© percorrer todos os pares (chave-valor) que existem dentro do mapa <code>hm</code> (que presumivelmente √© um <code>HashMap</code>).</p>
                    
                    <pre class="code-block"><code>
// (hm √© um Map, por exemplo: Map&lt;Integer, String&gt; hm)
// hm.put(1, "ValorA"); hm.put(2, "ValorB");

// 1. hm.entrySet() cria um CONJUNTO (Set) de todos os pares (Entries).
//    Ex: [ (1, "ValorA"), (2, "ValorB") ]
Set set = hm.entrySet();

// 2. Criamos um Iterator para percorrer esse conjunto
Iterator iterator = set.iterator();

while(iterator.hasNext()){
    // 4. iterator.next() pega o pr√≥ximo par (ex: (1, "ValorA"))
    //    O (Map.Entry) √© um 'cast' necess√°rio (vers√£o antiga do Java).
    Map.Entry mentry = (Map.Entry)iterator.next();

    // 5. Esta √© a linha da alternativa (b)
    //    mentry.getKey()   -> Pega a chave do par (ex: 1)
    //    mentry.getValue() -> Pega o valor do par (ex: "ValorA")
    System.out.print("A chave √©: " + mentry.getKey());    
    System.out.println("& o Valor √©: " + mentry.getValue());
}
// 6. O segundo bloco demonstra o acesso direto pela chave
String var = hm.get(2); // Busca o valor associado √† CHAVE 2
System.out.println("Valor na chave 2 √©: " + var); // Imprime "ValorB"
                    </code></pre>
                    
                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) Falso.</strong> <code>System.out.println</code> imprime a sa√≠da no **console** (terminal), n√£o em uma janela gr√°fica (JFrame).</li>
                        <li><strong>(c) Falso.</strong> O c√≥digo usa um <code>Map</code> como estrutura principal. Ele usa um <code>Set</code> (o <code>entrySet</code>) apenas como um meio para iterar. <code>Set</code> e <code>Map</code> t√™m prop√≥sitos diferentes.</li>
                        <li><strong>(d) Falso.</strong> <code>get(2)</code> busca o valor associado √† <strong>chave 2</strong>. O tipo do valor (a "resposta") pode ser qualquer um (no c√≥digo, √© uma <code>String</code>). N√£o h√° regra que exija que o valor seja <code>int</code>.</li>
                        <li><strong>(e) Falso.</strong> O <code>iterator.next()</code> de um <code>entrySet</code> retorna um objeto do tipo <code>Map.Entry</code>. O cast <code>(Map.Entry)</code> √© a maneira correta de atribuir esse objeto √† vari√°vel <code>mentry</code>.</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 18: TreeSet (Ordem Alfab√©tica)</h1>
                
                <p>Analise o c√≥digo a seguir em linguagem Java (qualquer vers√£o), que cria um conjunto de nomes com a classe TreeSet.</p>

                <pre class="code-block">
<code>
public static void main(String[] args) {
    TreeSet&lt;String&gt; dset = new TreeSet&lt;String&gt;();
    dset.add("Zoraide");
    dset.add("Maria");
    dset.add("Janete");
    dset.add("Jo√£o");
    dset.add("Heitor");
    Iterator&lt;String&gt; iterator = dset.iterator();
    while (iterator.hasNext()) {
        System.out.print(iterator.next() + " ");
    }
}
</code>
                </pre>

                <p class="question-text">Em rela√ß√£o ao c√≥digo apresentado, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) O c√≥digo iterator.next() retorna o pr√≥ximo nome por ordem de inser√ß√£o.</div>
                    <div class="option">(b) O c√≥digo iterator.hasNext() retorna o pr√≥ximo nome do conjunto em ordem alfab√©tica.</div>
                    <div class="option">(c) O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes por ordem de inser√ß√£o.</div>
                    <div class="option">(d) O c√≥digo iterator.next() retorna o conjunto dos nomes em ordem alfab√©tica.</div>
                    <div class="option option-correct" data-id="e">(e) O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes em ordem alfab√©tica.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (e)</h2>
                    <p><code>O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes em ordem alfab√©tica.</code></p>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com o C√≥digo</h3>
                    <p>A linha mais importante do c√≥digo √© a primeira:</p>
                    <pre class="code-block"><code>TreeSet&lt;String&gt; dset = new TreeSet&lt;String&gt;();</code></pre>
                    <p>A caracter√≠stica fundamental de um <strong>TreeSet</strong> √© que ele armazena seus elementos em uma estrutura de √°rvore (Red-Black Tree), o que garante que os elementos estar√£o <strong>automaticamente mantidos em ordem classificada</strong>.</p>
                    
                    
                    <h3>Analisando a Execu√ß√£o:</h3>
                    <pre class="code-block"><code>
// Embora voc√™ tenha inserido os nomes "fora de ordem"...
dset.add("Zoraide");
dset.add("Maria");
dset.add("Janete");
dset.add("Jo√£o");
dset.add("Heitor");

// ...o TreeSet os armazena internamente na ordem alfab√©tica:
// [Heitor, Janete, Jo√£o, Maria, Zoraide]
            </code></pre>
                    
                    <h3>O Loop (A Resposta):</h3>
                    <pre class="code-block"><code>
// O iterator de um TreeSet percorre a cole√ß√£o na sua ordem classificada.
while (iterator.hasNext()) {
    // iterator.next() busca o pr√≥ximo item NA ORDEM ALFAB√âTICA.
    System.out.print(iterator.next() + " ");
}
// Sa√≠da Esperada: Heitor Janete Jo√£o Maria Zoraide 
            </code></pre>

                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) e (c):</strong> Mencionam "ordem de inser√ß√£o". Isso est√° incorreto; essa seria a caracter√≠stica de um <code>LinkedHashSet</code>.</li>
                        <li><strong>(b):</strong> <code>iterator.hasNext()</code> retorna <code>true</code> ou <code>false</code> (um boolean), ele n√£o retorna o nome.</li>
                        <li><strong>(d):</strong> <code>iterator.next()</code> retorna <strong>um</strong> nome de cada vez, n√£o o "conjunto dos nomes" (o conjunto inteiro).</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 19: HashSet (Ordem)</h1>
                
                <p>Analise o c√≥digo a seguir em linguagem Java (qualquer vers√£o), que cria um conjunto de nomes com a classe HashSet.</p>

                <pre class="code-block">
<code>
public static void main(String[] args) {
    HashSet&lt;String&gt; dset = new HashSet&lt;String&gt;();
    dset.add("Zoraide");
    dset.add("Maria");
    dset.add("Janete");
    dset.add("Jo√£o");
    dset.add("Heitor");
    Iterator&lt;String&gt; iterator = dset.iterator();
    while (iterator.hasNext()) {
        System.out.print(iterator.next() + " ");
    }
}
</code>
                </pre>

                <p class="question-text">Em rela√ß√£o ao c√≥digo, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option">(a) O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes por ordem de inser√ß√£o.</div>
                    <div class="option">(b) O c√≥digo iterator.next() retorna o conjunto dos nomes em ordem alfab√©tica.</div>
                    <div class="option option-correct" data-id="c">(c) O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes n√£o necessariamente na ordem em que foram inseridos.</div>
                    <div class="option">(d) O c√≥digo iterator.hasNext() retorna o pr√≥ximo nome do conjunto em ordem alfab√©tica.</div>
                    <div class="option">(e) O c√≥digo iterator.next() retorna o pr√≥ximo nome em ordem de inser√ß√£o.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (c)</h2>
                    <p><code>O c√≥digo System.out.print(iterator.next() + " ") imprime os nomes n√£o necessariamente na ordem em que foram inseridos.</code></p>
                    
                    <h3>üñ•Ô∏è Explica√ß√£o com o C√≥digo</h3>
                    <p>A linha mais importante do c√≥digo √© a primeira:</p>
                    <pre class="code-block"><code>HashSet&lt;String&gt; dset = new HashSet&lt;String&gt;();</code></pre>
                    <p>A caracter√≠stica fundamental de um <strong>HashSet (Conjunto de Hash)</strong> √© que ele armazena seus elementos em uma tabela hash. A prioridade desta estrutura √© a <strong>velocidade</strong> para adicionar (<code>.add()</code>) e verificar (<code>.contains()</code>), que ela faz em tempo O(1) (constante).</p>
                    
                    
                    <h3>A Consequ√™ncia: Sem Ordem Garantida</h3>
                    <p>Para alcan√ßar essa velocidade, o <code>HashSet</code> n√£o se preocupa com a ordem:</p>
                    <ul>
                        <li>N√£o armazena os itens na ordem em que foram inseridos (como um <code>LinkedHashSet</code> faria).</li>
                        <li>N√£o armazena os itens em ordem alfab√©tica (como um <code>TreeSet</code> faria).</li>
                    </ul>
                    <p>A ordem de um <code>HashSet</code> √© "aparentemente aleat√≥ria", pois √© determinada pelo <code>hashCode()</code> de cada objeto.</p>

                    <h3>Analisando a Execu√ß√£o:</h3>
                    <pre class="code-block"><code>
// ... (adicionando "Zoraide", "Maria", "Janete", "Jo√£o", "Heitor")

// O iterator percorre o HashSet na ordem determinada pela tabela hash.
while (iterator.hasNext()) {
    System.out.print(iterator.next() + " ");
}
// Sa√≠da Prov√°vel:
// Maria Zoraide Heitor Jo√£o Janete 
// (A ordem exata pode mudar, mas N√ÉO √© a de inser√ß√£o/alfab√©tica)
                    </code></pre>
                    <p>A alternativa (c) √© a √∫nica que descreve perfeitamente esse comportamento.</p>
                    
                    <h3>‚ùå Por que as outras est√£o erradas?</h3>
                    <ul>
                        <li><strong>(a) e (e):</strong> Mencionam "ordem de inser√ß√£o". Incorreto (isso √© <code>LinkedHashSet</code>).</li>
                        <li><strong>(b) e (d):</strong> Mencionam "ordem alfab√©tica". Incorreto (isso √© <code>TreeSet</code>).</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="question-slide">
            <div class="quiz-container">
                <h1>Quest√£o 20: Pilha de Chamadas (Call Stack)</h1>
                
                <p>Quando um programa est√° sendo executado, uma se√ß√£o especial do espa√ßo de mem√≥ria... [texto omitido] ... Sobre o que foi apresentado, observe as asser√ß√µes a seguir e as rela√ß√µes propostas entre elas.</p>

                <div style="background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 5px; padding: 10px 15px;">
                    <p><strong>I.</strong> Quando a fun√ß√£o termina a execu√ß√£o, o c√≥digo de fun√ß√£o √© removido ou retirado do topo da pilha, que permite apenas que itens sejam adicionados ao topo; por isso, √© chamada de estrutura de dados LIFO (Last-In-First-Out).</p>
                    <p style="text-align: center; font-weight: bold;">PORQUE</p>
                    <p><strong>II.</strong> Cada vez que uma fun√ß√£o √© chamada, o c√≥digo da fun√ß√£o, bem como o espa√ßo para os argumentos da fun√ß√£o e os valores de retorno, s√£o colocados no topo da Pilha de Chamadas.</p>
                </div>

                <p class="question-text" style="margin-top: 15px;">Analisando as asser√ß√µes anteriores, assinale a alternativa correta.</p>

                <div class="options">
                    <div class="option option-correct" data-id="a">(a) As asser√ß√µes I e II s√£o proposi√ß√µes verdadeiras, e a II √© uma justificativa para I.</div>
                    <div class="option">(b) A asser√ß√£o II √© uma proposi√ß√£o verdadeira, e a I √© uma proposi√ß√£o falsa.</div>
                    <div class="option">(c) As asser√ß√µes I e II s√£o proposi√ß√µes verdadeiras, mas a II n√£o √© uma justificativa para I.</div>
                    <div class="option">(d) As asser√ß√µes I e II s√£o proposi√ß√µes falsas.</div>
                    <div class="option">(e) A asser√ß√£o I √© uma proposi√ß√£o verdadeira, e a II √© uma proposi√ß√£o falsa.</div>
                </div>

                <button class="toggle-answer-btn">Mostrar Resposta</button>

                <div class="answer-section" style="display: none;">
                    <h2>Resposta Correta: (a)</h2>
                    <p>As asser√ß√µes I e II s√£o proposi√ß√µes verdadeiras, e a II √© uma justificativa para I.</p>
                    
                    <h3>üñ•Ô∏è Explicando com C√≥digo</h3>
                    <p>A melhor maneira de entender a pilha √© com fun√ß√µes aninhadas (uma chamando a outra). A recurs√£o √© um caso especial disso, onde uma fun√ß√£o chama a si mesma. Vamos usar um exemplo simples:</p>
                    
                    <pre class="code-block"><code>
public class PilhaDeChamada {

    public static void main(String[] args) {
        System.out.println("1. In√≠cio do 'main'");
        metodoA(); // Chamada 1
        System.out.println("5. Fim do 'main'");
    }

    public static void metodoA() {
        System.out.println(" 2. In√≠cio do 'metodoA'");
        metodoB(); // Chamada 2
        System.out.println(" 4. Fim do 'metodoA'");
    }

    public static void metodoB() {
        System.out.println("  3. In√≠cio e Fim do 'metodoB' (Topo da Pilha)");
        // Este m√©todo n√£o chama mais ningu√©m, ent√£o ele termina.
    }
}
                    </code></pre>
                    
                    <h3>üë£ Rastreando a Pilha de Chamadas (Call Stack)</h3>
                    
                    <p>Vamos ver o que acontece na mem√≥ria passo a passo:</p>
                    <ol>
                        <li><strong>Passo 1:</strong> <code>main</code> √© chamado. <strong>(Asser√ß√£o II)</strong> <code>main</code> √© colocado na pilha.<br>
                            <strong>Pilha:</strong> <code>[ main ]</code></li>
                        <li><strong>Passo 2:</strong> <code>main</code> chama <code>metodoA</code>. <strong>(Asser√ß√£o II)</strong> <code>metodoA</code> √© colocado no topo.<br>
                            <strong>Pilha:</strong> <code>[ metodoA ]</code> &lt;-- TOPO, <code>[ main ]</code></li>
                        <li><strong>Passo 3:</strong> <code>metodoA</code> chama <code>metodoB</code>. <strong>(Asser√ß√£o II)</strong> <code>metodoB</code> √© colocado no topo.<br>
                            <strong>Pilha:</strong> <code>[ metodoB ]</code> &lt;-- TOPO, <code>[ metodoA ]</code>, <code>[ main ]</code></li>
                        <li><strong>Passo 4:</strong> <code>metodoB</code> termina. <strong>(Asser√ß√£o I)</strong> <code>metodoB</code> (o "Last-In") √© removido do topo (o "First-Out"). A execu√ß√£o volta para <code>metodoA</code>.<br>
                            <strong>Pilha:</strong> <code>[ metodoA ]</code> &lt;-- TOPO, <code>[ main ]</code></li>
                        <li><strong>Passo 5:</strong> <code>metodoA</code> termina. <strong>(Asser√ß√£o I)</strong> <code>metodoA</code> √© removido. A execu√ß√£o volta para <code>main</code>.<br>
                            <strong>Pilha:</strong> <code>[ main ]</code> &lt;-- TOPO</li>
                        <li><strong>Passo 6:</strong> <code>main</code> termina. <strong>(Asser√ß√£o I)</strong> <code>main</code> √© removido. A pilha fica vazia.</li>
                    </ol>

                    <h3>Conclus√£o</h3>
                    <ul>
                        <li><strong>Asser√ß√£o II (Verdadeira):</strong> O c√≥digo mostra que cada chamada (<code>main</code>, <code>metodoA</code>, <code>metodoB</code>) √© "empilhada" no topo.</li>
                        <li><strong>Asser√ß√£o I (Verdadeira):</strong> O c√≥digo mostra que quando uma fun√ß√£o termina (<code>metodoB</code>), ela √© "desempilhada" do topo. O √öltimo a Entrar (<code>metodoB</code>) foi o Primeiro a Sair. Isso √© LIFO.</li>
                        <li><strong>Rela√ß√£o (II justifica I):</strong> CORRETO. <strong>PORQUE</strong> as fun√ß√µes novas s√£o sempre colocadas no topo (II), a execu√ß√£o da fun√ß√£o anterior √© pausada e n√£o pode terminar at√© que a nova (que est√° "em cima") seja removida primeiro (I).</li>
                    </ul>
                </div>
            </div>
        </div>

        <button class="nav-arrow" id="prev-btn" title="Anterior">&larr;</button>
        <button class="nav-arrow" id="next-btn" title="Pr√≥ximo">&rarr;</button>
    </div>

    <script src="script.js"></script>
</body>
</html>